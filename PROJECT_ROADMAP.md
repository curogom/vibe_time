# VibeTime 프로젝트 로드맵

## 프로젝트 개요
VibeTime은 "바이브 코딩" 책의 실습 예제로 개발되는 AI 기반 적응형 시간 관리 애플리케이션입니다.

### 핵심 목표
- 📚 **교육 목적**: 독자들이 Claude Code와 함께 실제 작동하는 서비스를 만들어보는 학습 경험 제공
- 🚀 **실전 개발**: 단순한 예제가 아닌, 실제로 배포 가능한 수준의 완성도 높은 앱 구현
- 📖 **단계별 학습**: 각 챕터별로 기능을 추가하며 점진적으로 완성해가는 과정

## 기술 스택
- **모바일**: Flutter 3.32 (Provider/Riverpod, go_router, Material Design 3)
- **웹**: React + TypeScript + Vite (Zustand/Context API, Material-UI/Tailwind CSS)
- **백엔드**: Firebase (Auth, Firestore, Storage, Functions)
- **AI/ML**: 클라이언트 사이드 패턴 분석

## Git 브랜치 전략

```
main (최종 완성본)
├── chapter-3-warmup (워밍업 - 계산기 앱)
├── chapter-4-flutter-basics (Flutter 기초)
├── chapter-5-design-system (디자인 시스템)
├── chapter-6-navigation (네비게이션)
├── chapter-7-core-features (핵심 기능)
├── chapter-8-firebase (Firebase 연동)
├── chapter-9-advanced (고급 기능)
├── chapter-10-deployment (배포 준비)
├── chapter-11-web (웹 버전)
└── chapter-12-final (최종 완성)
```

## 챕터별 세부 로드맵

### 📱 Chapter 3: 워밍업 - 계산기 앱
**목표**: Claude Code와의 대화 방법 학습, 기본적인 앱 개발 프로세스 이해

#### 구현 항목
- [ ] Flutter 계산기 앱 (Flutter만)
  - [ ] 프로젝트 생성 및 초기 설정
  - [ ] 계산기 UI 레이아웃 (버튼 그리드)
  - [ ] 계산 로직 구현
  - [ ] 상태 관리 (setState 사용)
  - [ ] 에러 처리 (0으로 나누기 등)

#### 학습 포인트
- Claude Code에게 효과적으로 질문하기
- 에러 메시지 해석 및 해결
- 코드 리팩토링 요청하기

---

### 🎨 Chapter 4: Flutter 기초 - VibeTime 시작
**목표**: Flutter의 기본 위젯과 레이아웃 시스템 이해

#### 구현 항목
- [ ] VibeTime 프로젝트 생성
  - [ ] 프로젝트 구조 설정
  - [ ] 앱 테마 및 색상 정의
  - [ ] Material Design 3 적용

- [ ] 기본 위젯 실습
  - [ ] 프로필 카드 위젯
    - [ ] CircleAvatar로 프로필 이미지
    - [ ] 사용자 정보 표시
    - [ ] 통계 정보 (집중 시간, 완료 작업)
  
  - [ ] Instagram 스타일 포스트 UI
    - [ ] 이미지 캐러셀
    - [ ] 좋아요/댓글 인터랙션
    - [ ] 시간 표시 포맷팅

#### 학습 포인트
- Widget 트리 구조 이해
- Stateless vs Stateful Widget
- 레이아웃 위젯 (Row, Column, Stack)
- 기본적인 스타일링

---

### 🎯 Chapter 5: 디자인 시스템 구축
**목표**: 재사용 가능한 컴포넌트와 일관된 디자인 시스템 구축

#### 구현 항목
- [ ] 디자인 토큰 정의
  - [ ] 색상 팔레트 (Primary, Secondary, Semantic colors)
  - [ ] Typography 스케일
  - [ ] Spacing 시스템
  - [ ] Border radius, Shadow 정의

- [ ] 커스텀 컴포넌트
  - [ ] VibeButton
    - [ ] 다양한 크기 (small, medium, large)
    - [ ] 상태별 스타일 (enabled, disabled, loading)
    - [ ] 아이콘 지원
  
  - [ ] CustomTextField
    - [ ] 라벨, 힌트 텍스트
    - [ ] 에러 상태 표시
    - [ ] 입력 검증
  
  - [ ] TaskCard
    - [ ] 우선순위 표시
    - [ ] 예상/실제 시간
    - [ ] 스와이프 액션

- [ ] 반응형 레이아웃
  - [ ] LayoutBuilder 활용
  - [ ] 태블릿/폰 대응

#### 학습 포인트
- ThemeData 커스터마이징
- 커스텀 위젯 만들기
- 컴포지션 패턴
- 반응형 디자인 원칙

---

### 🧭 Chapter 6: 네비게이션과 라우팅
**목표**: 복잡한 앱 네비게이션 구조 구현

#### 구현 항목
- [ ] 온보딩 플로우
  - [ ] 3단계 온보딩 화면
  - [ ] PageView로 스와이프
  - [ ] 진행 표시기
  - [ ] 건너뛰기/다음 버튼

- [ ] go_router 설정
  - [ ] 라우트 정의
  - [ ] 중첩 라우팅
  - [ ] 라우트 가드 (인증 체크)
  - [ ] 딥링크 처리

- [ ] 하단 네비게이션
  - [ ] 4개 탭 (홈, 작업, 통계, 설정)
  - [ ] 탭별 상태 유지
  - [ ] 커스텀 네비게이션 바

#### 학습 포인트
- 선언적 라우팅
- 네비게이션 상태 관리
- 딥링크 처리
- 화면 전환 애니메이션

---

### ⏱️ Chapter 7: 핵심 기능 - 타이머와 작업 관리
**목표**: VibeTime의 핵심 기능 구현

#### 구현 항목
- [ ] 적응형 타이머 시스템
  - [ ] 타이머 로직 (시작, 정지, 리셋)
  - [ ] 백그라운드 동작
  - [ ] 원형 프로그레스 UI
  - [ ] 시간 조정 알고리즘
    - [ ] 기본 25분
    - [ ] 15-90분 범위 조정
    - [ ] 생산성 기반 학습

- [ ] 작업 관리 CRUD
  - [ ] 작업 생성 폼
  - [ ] 우선순위 설정 (low, medium, high, urgent)
  - [ ] 태그 시스템
  - [ ] 예상 시간 입력
  - [ ] 작업 목록 필터/정렬

- [ ] 스케줄러 UI
  - [ ] 시간 블록 뷰
  - [ ] 드래그 앤 드롭
  - [ ] 작업 시간 할당
  - [ ] 자동 휴식 시간

- [ ] Provider 상태 관리
  - [ ] TimerProvider
  - [ ] TaskProvider
  - [ ] ScheduleProvider

#### 학습 포인트
- 복잡한 상태 관리
- 타이머와 생명주기
- 드래그 앤 드롭 구현
- 로컬 데이터 저장

---

### ☁️ Chapter 8: Firebase 통합
**목표**: 클라우드 백엔드 연동 및 실시간 동기화

#### 구현 항목
- [ ] Firebase 프로젝트 설정
  - [ ] Firebase 프로젝트 생성
  - [ ] iOS/Android 앱 등록
  - [ ] 환경별 설정 (dev/prod)

- [ ] 인증 시스템
  - [ ] 이메일/비밀번호 로그인
  - [ ] Google 소셜 로그인
  - [ ] 비밀번호 재설정
  - [ ] 프로필 관리

- [ ] Firestore 데이터 모델
  - [ ] users 컬렉션
  - [ ] tasks 컬렉션
  - [ ] sessions 컬렉션
  - [ ] 보안 규칙 설정

- [ ] 실시간 동기화
  - [ ] 스트림 기반 데이터 바인딩
  - [ ] 오프라인 지원
  - [ ] 충돌 해결 전략

#### 학습 포인트
- Firebase 설정 및 초기화
- 인증 플로우 구현
- NoSQL 데이터 모델링
- 실시간 리스너 패턴

---

### 📊 Chapter 9: 고급 기능 - 분석과 AI
**목표**: 데이터 시각화와 AI 추천 시스템 구현

#### 구현 항목
- [ ] 생산성 대시보드
  - [ ] fl_chart 라이브러리 활용
  - [ ] 일간/주간/월간 차트
  - [ ] 생산성 히트맵
  - [ ] 작업별 시간 분포

- [ ] 통계 기능
  - [ ] 총 집중 시간
  - [ ] 완료 작업 수
  - [ ] 평균 세션 길이
  - [ ] 목표 달성률

- [ ] AI 추천 시스템
  - [ ] 시간대별 생산성 분석
  - [ ] 최적 작업 시간 추천
  - [ ] 휴식 시간 제안
  - [ ] 작업 우선순위 조정

- [ ] 로컬 알림
  - [ ] 세션 시작/종료 알림
  - [ ] 휴식 시간 알림
  - [ ] 일일 리마인더

#### 학습 포인트
- 데이터 시각화 기법
- 차트 라이브러리 활용
- 로컬 머신러닝
- 알림 시스템 구현

---

### 🚀 Chapter 10: 배포 준비
**목표**: 앱 스토어 배포를 위한 최종 준비

#### 구현 항목
- [ ] 성능 최적화
  - [ ] 이미지 최적화
  - [ ] 레이지 로딩
  - [ ] 메모리 프로파일링
  - [ ] 빌드 크기 최적화

- [ ] 테스트 작성
  - [ ] 단위 테스트 (비즈니스 로직)
  - [ ] 위젯 테스트 (UI 컴포넌트)
  - [ ] 통합 테스트 (주요 플로우)

- [ ] 앱 에셋 준비
  - [ ] 앱 아이콘 (iOS/Android)
  - [ ] 스플래시 화면
  - [ ] 스크린샷
  - [ ] 앱 설명 작성

- [ ] 배포 설정
  - [ ] 번들 ID/패키지명
  - [ ] 버전 관리
  - [ ] 서명 설정
  - [ ] 스토어 메타데이터

#### 학습 포인트
- 앱 최적화 기법
- 테스트 전략
- 스토어 가이드라인
- CI/CD 파이프라인

---

### 🌐 Chapter 11: 웹 버전 개발
**목표**: Flutter Web과 React로 웹 버전 구현

#### 구현 항목
- [ ] Flutter Web
  - [ ] 웹 빌드 설정
  - [ ] 반응형 레이아웃 조정
  - [ ] 웹 특화 기능
  - [ ] PWA 설정

- [ ] React 버전 시작
  - [ ] 프로젝트 구조
  - [ ] 주요 컴포넌트 변환
  - [ ] Zustand 상태 관리
  - [ ] Firebase 연동

- [ ] 웹 배포
  - [ ] Vercel 설정
  - [ ] 도메인 연결
  - [ ] 환경 변수
  - [ ] 모니터링

#### 학습 포인트
- 크로스 플랫폼 개발
- 웹 최적화
- React 생태계
- 배포 자동화

---

### 🎯 Chapter 12: 최종 완성과 확장
**목표**: 모든 기능 통합 및 향후 확장 가능성 준비

#### 구현 항목
- [ ] 기능 통합 테스트
  - [ ] 전체 사용자 플로우 검증
  - [ ] 크로스 플랫폼 동기화
  - [ ] 엣지 케이스 처리

- [ ] 문서화
  - [ ] README 작성
  - [ ] API 문서
  - [ ] 기여 가이드
  - [ ] 라이선스

- [ ] 확장 가능성
  - [ ] 플러그인 시스템 설계
  - [ ] API 공개 준비
  - [ ] 다국어 지원 구조
  - [ ] 팀 기능 아키텍처

#### 학습 포인트
- 프로젝트 완성도
- 오픈소스 준비
- 확장 가능한 설계
- 커뮤니티 구축

## 독자를 위한 가이드

### 브랜치 사용법
```bash
# 특정 챕터의 완성 코드 확인
git checkout chapter-7-core-features

# 챕터 간 차이점 확인
git diff chapter-6-navigation chapter-7-core-features

# 자신의 브랜치에서 작업
git checkout -b my-chapter-7
```

### 각 브랜치의 README 구조
각 챕터 브랜치에는 다음 내용이 포함된 README.md가 있습니다:
- 🎯 이 챕터에서 배우는 것
- 📝 주요 프롬프트 예시
- 💡 프롬프트 작성 팁
- 🛠 구현된 기능 목록
- 📦 추가된 패키지
- 🚀 실행 방법
- 📂 주요 파일 설명
- 🔍 다음 챕터 미리보기

### 커밋 메시지 컨벤션
```
feat: 새로운 기능 추가
fix: 버그 수정
refactor: 코드 개선
style: 코드 스타일 변경
docs: 문서 수정
test: 테스트 추가
```

## 교육적 성공 지표

### 학습 목표 달성
- ✅ 독자가 Claude Code와 대화하여 완전한 앱을 만들 수 있음
- ✅ Flutter와 React 모두에서 동일한 서비스 구현 가능
- ✅ 실제 배포 가능한 수준의 품질 달성
- ✅ AI와 협업하는 개발 방식 체득

### 프로젝트 완성도
- 모든 핵심 기능이 실제로 작동
- 테스트 코드 포함
- 성능 최적화 완료
- 스토어 배포 가능 상태

### 독자 피드백 (예상)
- "실제로 작동하는 앱을 만들 수 있어서 놀랍다"
- "각 챕터별로 따라하기 쉽게 구성되어 있다"
- "AI와 대화하는 방법을 제대로 배웠다"
- "이제 나만의 앱을 만들 자신감이 생겼다"